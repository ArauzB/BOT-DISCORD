"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageEmbedComponent = exports.MessageComponent = exports.Activity = exports.ReactionEvent = exports.Reaction = exports.DiscordActivity = void 0;
var events_1 = require("events");
var discord_js_1 = __importDefault(require("discord.js"));
var components_1 = require("./components");
Object.defineProperty(exports, "MessageComponent", { enumerable: true, get: function () { return components_1.MessageComponent; } });
Object.defineProperty(exports, "MessageEmbedComponent", { enumerable: true, get: function () { return components_1.MessageEmbedComponent; } });
var reaction_1 = __importStar(require("./reaction"));
exports.Reaction = reaction_1.default;
Object.defineProperty(exports, "ReactionEvent", { enumerable: true, get: function () { return reaction_1.ReactionEvent; } });
var activity_1 = __importDefault(require("./activity"));
exports.Activity = activity_1.default;
var DiscordActivity = /** @class */ (function (_super) {
    __extends(DiscordActivity, _super);
    function DiscordActivity(props) {
        if (props === void 0) { props = {}; }
        var _this = _super.call(this) || this;
        _this.channelId = null;
        _this._removeMessage = props.autoRemoveMessage !== undefined ? props.autoRemoveMessage : false;
        _this._removeAllMessage = props.removeAllMessage !== undefined ? props.removeAllMessage : false;
        _this._isReady = false;
        _this._updatePending = 0;
        _this.currentActivity = null;
        _this.activity = [];
        _this.client = props.client || new discord_js_1.default.Client();
        _this.client.on('error', function (err) { return _this.emit('error', err); });
        _this.client.on('ready', function () { return _this.emit('client_ready'); });
        _this.on('client_ready', function () { return _this.onClientReady(); });
        _this.on('update', function () { return _this.onUpdate(); });
        _this.client.on('messageReactionRemove', function (message, user) { return _this.onMessageReactionRemove(message, user); });
        _this.client.on('messageReactionAdd', function (message, user) { return _this.onMessageReactionAdd(message, user); });
        _this.client.on("message", function (message) { return _this.onMessage(message); });
        return _this;
    }
    DiscordActivity.prototype.login = function (token, channelId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!channelId)
                            throw new Error('You must provide a channelId');
                        if (!token)
                            throw new Error('You must provide a token');
                        this.channelId = channelId;
                        return [4 /*yield*/, this.client.login(token)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    DiscordActivity.prototype.getActivity = function (activityId) {
        return this.activity.find(function (i) { return (i.name === activityId || i.id === activityId); }) || null;
    };
    DiscordActivity.prototype.createActivity = function (_a) {
        if (_a === void 0) { _a = {}; }
        var isActive = _a.isActive, props = __rest(_a, ["isActive"]);
        if (props && props.name) {
            if (this.getActivity(props.name)) {
                throw new Error('this activity name is already in use');
            }
        }
        var activity = new activity_1.default(props);
        return this.addActivity(activity, isActive);
    };
    DiscordActivity.prototype.addActivity = function (activity, isActive) {
        var _this = this;
        this.activity.push(activity);
        activity.on('update', function () { return _this.update(); });
        activity.on('mounted', (function (activity) { return _this.emit('mounted', activity); }).bind(this, activity));
        activity.on('unmounted', (function (activity) { return _this.emit('unmounted', activity); }).bind(this, activity));
        if (isActive)
            this.setActive(activity);
        return activity;
    };
    DiscordActivity.prototype.setActive = function (activityId) {
        var activity = this.getActivity(activityId instanceof activity_1.default ? activityId.id : activityId);
        if (!activity)
            return null;
        if (this.currentActivity && this.currentActivity.isMount())
            this.currentActivity.unmount();
        this.currentActivity = activity;
        if (this._isReady)
            this.update();
        return activity;
    };
    DiscordActivity.prototype.getChannel = function () {
        return __awaiter(this, void 0, void 0, function () {
            var channel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._isReady)
                            return [2 /*return*/, null];
                        if (!this.channelId)
                            return [2 /*return*/, null];
                        return [4 /*yield*/, this.client.channels.fetch(this.channelId)];
                    case 1:
                        channel = _a.sent();
                        if (channel.type !== 'text' && !(channel instanceof discord_js_1.default.TextChannel))
                            return [2 /*return*/, null];
                        return [2 /*return*/, channel];
                }
            });
        });
    };
    DiscordActivity.prototype.getUser = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.client.user];
            });
        });
    };
    DiscordActivity.prototype.render = function () {
        return __awaiter(this, void 0, void 0, function () {
            var currentActivity, channel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._isReady)
                            return [2 /*return*/, false];
                        currentActivity = this.currentActivity;
                        return [4 /*yield*/, this.getChannel()];
                    case 1:
                        channel = _a.sent();
                        if (!channel)
                            throw new Error('Fail to fetch channel or invalid channel type');
                        if (channel.deleted)
                            throw new Error('Channel has been deleted');
                        if (!currentActivity) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentActivity.mount(channel)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, true];
                    case 3: return [2 /*return*/, false];
                }
            });
        });
    };
    DiscordActivity.prototype._clear = function () {
        return __awaiter(this, void 0, void 0, function () {
            var channel, messages, _i, _a, message;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this._removeAllMessage)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, this.getChannel()];
                    case 1:
                        channel = _b.sent();
                        if (!channel || channel.deleted)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, channel.messages.fetch()];
                    case 2:
                        messages = _b.sent();
                        _i = 0, _a = messages.array();
                        _b.label = 3;
                    case 3:
                        if (!(_i < _a.length)) return [3 /*break*/, 6];
                        message = _a[_i];
                        return [4 /*yield*/, message.delete()];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 3];
                    case 6:
                        if (!(this.currentActivity && this.currentActivity.isMount())) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.currentActivity.unmount()];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [2 /*return*/, true];
                }
            });
        });
    };
    DiscordActivity.prototype.update = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this._updatePending)
                    return [2 /*return*/];
                this._updatePending++;
                setTimeout(function () {
                    _this.emit('update');
                }, 1000);
                return [2 /*return*/];
            });
        });
    };
    // Events
    DiscordActivity.prototype.onClientReady = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._isReady = true;
                        if (!this._removeAllMessage) return [3 /*break*/, 2];
                        //  Cleanup all messages
                        return [4 /*yield*/, this._clear()];
                    case 1:
                        //  Cleanup all messages
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this.update();
                        this.emit('ready');
                        return [2 /*return*/];
                }
            });
        });
    };
    DiscordActivity.prototype.onMessageReactionAdd = function (messageReaction, user) {
        return __awaiter(this, void 0, void 0, function () {
            var currentActivity, message, currentUser, component, reaction, event;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentActivity = this.currentActivity;
                        if (!currentActivity)
                            throw new Error('Fail to tertermine the current activity');
                        message = messageReaction.message;
                        return [4 /*yield*/, this.getUser()];
                    case 1:
                        currentUser = _a.sent();
                        if (!currentUser)
                            throw new Error('Fail to tertermine the current user');
                        if (!(message.channel.id === this.channelId)) return [3 /*break*/, 6];
                        if (!(message.author.id === currentUser.id)) return [3 /*break*/, 6];
                        if (!(user.id !== currentUser.id)) return [3 /*break*/, 6];
                        return [4 /*yield*/, currentActivity.getComponentContext(message.id)];
                    case 2:
                        component = _a.sent();
                        if (!component) return [3 /*break*/, 6];
                        return [4 /*yield*/, component.getReactionContext(messageReaction.emoji)];
                    case 3:
                        reaction = _a.sent();
                        if (!reaction) return [3 /*break*/, 6];
                        event = new reaction_1.ReactionEvent('add', user, messageReaction);
                        return [4 /*yield*/, reaction._onAdd(event)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.update()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    DiscordActivity.prototype.onMessageReactionRemove = function (messageReaction, user) {
        return __awaiter(this, void 0, void 0, function () {
            var currentActivity, message, currentUser, component, reaction, event;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentActivity = this.currentActivity;
                        if (!currentActivity)
                            throw new Error('Fail to tertermine the current activity');
                        message = messageReaction.message;
                        return [4 /*yield*/, this.getUser()];
                    case 1:
                        currentUser = _a.sent();
                        if (!currentUser)
                            throw new Error('Fail to tertermine the current user');
                        if (!(message.channel.id === this.channelId)) return [3 /*break*/, 6];
                        if (!(message.author.id === currentUser.id)) return [3 /*break*/, 6];
                        if (!(user.id !== currentUser.id)) return [3 /*break*/, 6];
                        return [4 /*yield*/, currentActivity.getComponentContext(message.id)];
                    case 2:
                        component = _a.sent();
                        if (!component) return [3 /*break*/, 6];
                        return [4 /*yield*/, component.getReactionContext(messageReaction.emoji)];
                    case 3:
                        reaction = _a.sent();
                        if (!reaction) return [3 /*break*/, 6];
                        event = new reaction_1.ReactionEvent('remove', user, messageReaction);
                        return [4 /*yield*/, reaction._onRemove(event)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.update()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    DiscordActivity.prototype.onMessage = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var user;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getUser()];
                    case 1:
                        user = _a.sent();
                        if (!user)
                            throw new Error('Fail to tertermine the current user');
                        if (this._removeMessage) {
                            if (message.channel.id === this.channelId) {
                                if (message.author.id !== user.id) {
                                    message.delete();
                                }
                            }
                        }
                        this.emit('message', message);
                        return [2 /*return*/];
                }
            });
        });
    };
    DiscordActivity.prototype.onUpdate = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._updatePending--;
                        return [4 /*yield*/, this.render()];
                    case 1:
                        _a.sent();
                        this.emit('updated');
                        return [2 /*return*/];
                }
            });
        });
    };
    return DiscordActivity;
}(events_1.EventEmitter));
exports.DiscordActivity = DiscordActivity;
exports.default = DiscordActivity;
//# sourceMappingURL=index.js.map